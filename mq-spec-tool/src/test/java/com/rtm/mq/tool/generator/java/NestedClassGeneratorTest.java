package com.rtm.mq.tool.generator.java;

import com.rtm.mq.tool.config.Config;
import com.rtm.mq.tool.config.JavaConfig;
import com.rtm.mq.tool.model.FieldGroup;
import com.rtm.mq.tool.model.FieldNode;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Arrays;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Unit tests for NestedClassGenerator.
 *
 * <p>Tests cover:</p>
 * <ul>
 *   <li>Array element class generation</li>
 *   <li>Nested object class generation</li>
 *   <li>Class name derivation rules</li>
 *   <li>Transitory field exclusion</li>
 *   <li>Deep nesting (3+ levels)</li>
 *   <li>Duplicate class name handling</li>
 *   <li>Lombok vs manual getter/setter generation</li>
 *   <li>Builder pattern generation</li>
 *   <li>Field order preservation</li>
 *   <li>File output and encoding</li>
 * </ul>
 */
class NestedClassGeneratorTest {

    private Config config;
    private NestedClassGenerator generator;

    @BeforeEach
    void setUp() {
        config = new Config();
        config.setDefaults();
        JavaConfig javaConfig = new JavaConfig();
        javaConfig.setPackageName("com.rtm.test.model");
        config.setJava(javaConfig);
        generator = new NestedClassGenerator(config);
    }

    @Nested
    @DisplayName("Array Element Class Generation Tests")
    class ArrayElementClassGenerationTests {

        @Test
        @DisplayName("Generates class for array field with children")
        void generatesArrayElementClass() {
            FieldNode arrayField = FieldNode.builder()
                    .originalName("CBA_CARD_ARR")
                    .camelCaseName("cbaCardArr")
                    .isArray(true)
                    .children(Arrays.asList(
                            FieldNode.builder()
                                    .originalName("CARD_NO")
                                    .camelCaseName("cardNo")
                                    .dataType("String")
                                    .length(16)
                                    .build(),
                            FieldNode.builder()
                                    .originalName("CARD_TYPE")
                                    .camelCaseName("cardType")
                                    .dataType("String")
                                    .length(2)
                                    .build()
                    ))
                    .build();

            FieldGroup fieldGroup = new FieldGroup();
            fieldGroup.addField(arrayField);

            List<String> classNames = generator.generateNestedClasses(fieldGroup);

            assertEquals(1, classNames.size());
            assertEquals("CbaCardArray", classNames.get(0));

            String content = generator.getGeneratedContent("CbaCardArray");
            assertNotNull(content);
            assertTrue(content.contains("public class CbaCardArray"));
            assertTrue(content.contains("private String cardNo;"));
            assertTrue(content.contains("private String cardType;"));
            assertTrue(content.contains("@generated by MQ Tool"));
        }

        @Test
        @DisplayName("Array class name removes Arr suffix")
        void arrayClassNameRemovesArrSuffix() {
            FieldNode field = FieldNode.builder()
                    .camelCaseName("itemArr")
                    .build();

            String className = generator.deriveArrayClassName(field);
            assertEquals("ItemArray", className);
        }

        @Test
        @DisplayName("Array class name removes Array suffix")
        void arrayClassNameRemovesArraySuffix() {
            FieldNode field = FieldNode.builder()
                    .camelCaseName("itemArray")
                    .build();

            String className = generator.deriveArrayClassName(field);
            assertEquals("ItemArray", className);
        }

        @Test
        @DisplayName("Array class name removes List suffix")
        void arrayClassNameRemovesListSuffix() {
            FieldNode field = FieldNode.builder()
                    .camelCaseName("itemList")
                    .build();

            String className = generator.deriveArrayClassName(field);
            assertEquals("ItemArray", className);
        }

        @Test
        @DisplayName("Array class name case insensitive suffix removal")
        void arrayClassNameCaseInsensitiveSuffixRemoval() {
            FieldNode field = FieldNode.builder()
                    .camelCaseName("itemARR")
                    .build();

            String className = generator.deriveArrayClassName(field);
            assertEquals("ItemArray", className);
        }

        @Test
        @DisplayName("Array field with BigDecimal generates correct type")
        void arrayFieldWithBigDecimalType() {
            FieldNode arrayField = FieldNode.builder()
                    .originalName("AMOUNTS")
                    .camelCaseName("amounts")
                    .isArray(true)
                    .children(Arrays.asList(
                            FieldNode.builder()
                                    .originalName("AMOUNT")
                                    .camelCaseName("amount")
                                    .dataType("Amount")
                                    .build()
                    ))
                    .build();

            FieldGroup fieldGroup = new FieldGroup();
            fieldGroup.addField(arrayField);

            generator.generateNestedClasses(fieldGroup);

            String content = generator.getGeneratedContent("AmountArray");
            assertNotNull(content);
            assertTrue(content.contains("import java.math.BigDecimal;"));
            assertTrue(content.contains("private BigDecimal amount;"));
        }
    }

    @Nested
    @DisplayName("Nested Object Class Generation Tests")
    class NestedObjectClassGenerationTests {

        @Test
        @DisplayName("Generates class for object field with children")
        void generatesObjectClass() {
            FieldNode objectField = FieldNode.builder()
                    .originalName("CREATE_APP")
                    .camelCaseName("createApp")
                    .isObject(true)
                    .children(Arrays.asList(
                            FieldNode.builder()
                                    .originalName("APP_DATE")
                                    .camelCaseName("appDate")
                                    .dataType("String")
                                    .length(8)
                                    .build(),
                            FieldNode.builder()
                                    .originalName("APP_TIME")
                                    .camelCaseName("appTime")
                                    .dataType("String")
                                    .length(6)
                                    .build()
                    ))
                    .build();

            FieldGroup fieldGroup = new FieldGroup();
            fieldGroup.addField(objectField);

            List<String> classNames = generator.generateNestedClasses(fieldGroup);

            assertEquals(1, classNames.size());
            assertEquals("CreateApp", classNames.get(0));

            String content = generator.getGeneratedContent("CreateApp");
            assertNotNull(content);
            assertTrue(content.contains("public class CreateApp"));
            assertTrue(content.contains("private String appDate;"));
            assertTrue(content.contains("private String appTime;"));
        }

        @Test
        @DisplayName("Object class name is PascalCase from camelCaseName")
        void objectClassNameIsPascalCase() {
            FieldNode field = FieldNode.builder()
                    .camelCaseName("paymentDetails")
                    .build();

            String className = generator.deriveObjectClassName(field);
            assertEquals("PaymentDetails", className);
        }

        @Test
        @DisplayName("Object class uses explicit className if set")
        void objectClassUsesExplicitClassName() {
            FieldNode field = FieldNode.builder()
                    .camelCaseName("paymentDetails")
                    .className("PaymentInfo")
                    .build();

            String className = generator.deriveObjectClassName(field);
            assertEquals("PaymentInfo", className);
        }
    }

    @Nested
    @DisplayName("Transitory Field Exclusion Tests")
    class TransitoryFieldExclusionTests {

        @Test
        @DisplayName("Transitory fields are excluded from generated class")
        void transitoryFieldsExcluded() {
            FieldNode arrayField = FieldNode.builder()
                    .originalName("ITEMS")
                    .camelCaseName("items")
                    .isArray(true)
                    .children(Arrays.asList(
                            FieldNode.builder()
                                    .originalName("groupId")
                                    .camelCaseName("groupId")
                                    .isTransitory(true)
                                    .build(),
                            FieldNode.builder()
                                    .originalName("occurrenceCount")
                                    .camelCaseName("occurrenceCount")
                                    .isTransitory(true)
                                    .build(),
                            FieldNode.builder()
                                    .originalName("ITEM_NAME")
                                    .camelCaseName("itemName")
                                    .dataType("String")
                                    .build()
                    ))
                    .build();

            FieldGroup fieldGroup = new FieldGroup();
            fieldGroup.addField(arrayField);

            generator.generateNestedClasses(fieldGroup);

            String content = generator.getGeneratedContent("ItemArray");
            assertNotNull(content);
            assertTrue(content.contains("private String itemName;"));
            assertFalse(content.contains("private String groupId;"));
            assertFalse(content.contains("private String occurrenceCount;"));
        }

        @Test
        @DisplayName("Transitory array/object fields are skipped entirely")
        void transitoryContainerFieldsSkipped() {
            FieldNode transitoryArray = FieldNode.builder()
                    .originalName("INTERNAL_DATA")
                    .camelCaseName("internalData")
                    .isArray(true)
                    .isTransitory(true)
                    .children(Arrays.asList(
                            FieldNode.builder()
                                    .originalName("VALUE")
                                    .camelCaseName("value")
                                    .dataType("String")
                                    .build()
                    ))
                    .build();

            FieldGroup fieldGroup = new FieldGroup();
            fieldGroup.addField(transitoryArray);

            List<String> classNames = generator.generateNestedClasses(fieldGroup);

            assertTrue(classNames.isEmpty());
        }
    }

    @Nested
    @DisplayName("Deep Nesting Tests")
    class DeepNestingTests {

        @Test
        @DisplayName("Handles 3+ levels of nesting")
        void handlesDeepNesting() {
            // Level 3: deepest child
            FieldNode level3 = FieldNode.builder()
                    .originalName("LEVEL3")
                    .camelCaseName("level3")
                    .isObject(true)
                    .children(Arrays.asList(
                            FieldNode.builder()
                                    .originalName("VALUE")
                                    .camelCaseName("value")
                                    .dataType("String")
                                    .build()
                    ))
                    .build();

            // Level 2: contains Level 3
            FieldNode level2 = FieldNode.builder()
                    .originalName("LEVEL2")
                    .camelCaseName("level2")
                    .isObject(true)
                    .children(Arrays.asList(level3))
                    .build();

            // Level 1: contains Level 2
            FieldNode level1 = FieldNode.builder()
                    .originalName("LEVEL1")
                    .camelCaseName("level1")
                    .isObject(true)
                    .children(Arrays.asList(level2))
                    .build();

            FieldGroup fieldGroup = new FieldGroup();
            fieldGroup.addField(level1);

            List<String> classNames = generator.generateNestedClasses(fieldGroup);

            assertEquals(3, classNames.size());
            assertTrue(classNames.contains("Level1"));
            assertTrue(classNames.contains("Level2"));
            assertTrue(classNames.contains("Level3"));

            // Verify each class was generated
            assertNotNull(generator.getGeneratedContent("Level1"));
            assertNotNull(generator.getGeneratedContent("Level2"));
            assertNotNull(generator.getGeneratedContent("Level3"));
        }

        @Test
        @DisplayName("Handles mixed array and object nesting")
        void handlesMixedNesting() {
            FieldNode innerObject = FieldNode.builder()
                    .originalName("DETAILS")
                    .camelCaseName("details")
                    .isObject(true)
                    .children(Arrays.asList(
                            FieldNode.builder()
                                    .originalName("INFO")
                                    .camelCaseName("info")
                                    .dataType("String")
                                    .build()
                    ))
                    .build();

            FieldNode outerArray = FieldNode.builder()
                    .originalName("ITEMS")
                    .camelCaseName("items")
                    .isArray(true)
                    .children(Arrays.asList(innerObject))
                    .build();

            FieldGroup fieldGroup = new FieldGroup();
            fieldGroup.addField(outerArray);

            List<String> classNames = generator.generateNestedClasses(fieldGroup);

            assertEquals(2, classNames.size());
            assertTrue(classNames.contains("ItemArray"));
            assertTrue(classNames.contains("Details"));
        }
    }

    @Nested
    @DisplayName("Duplicate Class Name Handling Tests")
    class DuplicateClassNameTests {

        @Test
        @DisplayName("Same class name is only generated once")
        void sameClassNameGeneratedOnce() {
            FieldNode array1 = FieldNode.builder()
                    .originalName("ITEMS1")
                    .camelCaseName("items1")
                    .className("SharedItem")
                    .isArray(true)
                    .children(Arrays.asList(
                            FieldNode.builder()
                                    .originalName("VALUE")
                                    .camelCaseName("value")
                                    .dataType("String")
                                    .build()
                    ))
                    .build();

            FieldNode array2 = FieldNode.builder()
                    .originalName("ITEMS2")
                    .camelCaseName("items2")
                    .className("SharedItem")
                    .isArray(true)
                    .children(Arrays.asList(
                            FieldNode.builder()
                                    .originalName("VALUE")
                                    .camelCaseName("value")
                                    .dataType("String")
                                    .build()
                    ))
                    .build();

            FieldGroup fieldGroup = new FieldGroup();
            fieldGroup.addField(array1);
            fieldGroup.addField(array2);

            List<String> classNames = generator.generateNestedClasses(fieldGroup);

            assertEquals(1, classNames.size());
            assertEquals("SharedItem", classNames.get(0));
        }
    }

    @Nested
    @DisplayName("Lombok Annotation Tests")
    class LombokAnnotationTests {

        @Test
        @DisplayName("Generates Lombok annotations when enabled")
        void generatesLombokAnnotations() {
            JavaConfig javaConfig = new JavaConfig();
            javaConfig.setPackageName("com.rtm.test.model");
            javaConfig.setUseLombok(true);
            config.setJava(javaConfig);
            generator = new NestedClassGenerator(config);

            FieldNode objectField = FieldNode.builder()
                    .originalName("DATA")
                    .camelCaseName("data")
                    .isObject(true)
                    .children(Arrays.asList(
                            FieldNode.builder()
                                    .originalName("VALUE")
                                    .camelCaseName("value")
                                    .dataType("String")
                                    .build()
                    ))
                    .build();

            FieldGroup fieldGroup = new FieldGroup();
            fieldGroup.addField(objectField);

            generator.generateNestedClasses(fieldGroup);

            String content = generator.getGeneratedContent("Data");
            assertNotNull(content);
            assertTrue(content.contains("import lombok.Data;"));
            assertTrue(content.contains("import lombok.Builder;"));
            assertTrue(content.contains("import lombok.NoArgsConstructor;"));
            assertTrue(content.contains("import lombok.AllArgsConstructor;"));
            assertTrue(content.contains("@Data"));
            assertTrue(content.contains("@Builder"));
            assertTrue(content.contains("@NoArgsConstructor"));
            assertTrue(content.contains("@AllArgsConstructor"));
            // Should not have manual getter/setter
            assertFalse(content.contains("public String getValue()"));
            assertFalse(content.contains("public void setValue("));
        }

        @Test
        @DisplayName("Lombok array fields have @Builder.Default annotation")
        void lombokArrayFieldsHaveBuilderDefault() {
            JavaConfig javaConfig = new JavaConfig();
            javaConfig.setPackageName("com.rtm.test.model");
            javaConfig.setUseLombok(true);
            config.setJava(javaConfig);
            generator = new NestedClassGenerator(config);

            FieldNode objectField = FieldNode.builder()
                    .originalName("CONTAINER")
                    .camelCaseName("container")
                    .isObject(true)
                    .children(Arrays.asList(
                            FieldNode.builder()
                                    .originalName("ITEMS")
                                    .camelCaseName("items")
                                    .isArray(true)
                                    .className("Item")
                                    .build()
                    ))
                    .build();

            FieldGroup fieldGroup = new FieldGroup();
            fieldGroup.addField(objectField);

            generator.generateNestedClasses(fieldGroup);

            String content = generator.getGeneratedContent("Container");
            assertNotNull(content);
            assertTrue(content.contains("@Builder.Default"));
            assertTrue(content.contains("private List<Item> items = new ArrayList<>();"));
        }
    }

    @Nested
    @DisplayName("Manual Getter/Setter/Builder Tests")
    class ManualGetterSetterBuilderTests {

        @Test
        @DisplayName("Generates getter/setter when Lombok disabled")
        void generatesGetterSetterWithoutLombok() {
            FieldNode objectField = FieldNode.builder()
                    .originalName("DATA")
                    .camelCaseName("data")
                    .isObject(true)
                    .children(Arrays.asList(
                            FieldNode.builder()
                                    .originalName("VALUE")
                                    .camelCaseName("value")
                                    .dataType("String")
                                    .build()
                    ))
                    .build();

            FieldGroup fieldGroup = new FieldGroup();
            fieldGroup.addField(objectField);

            generator.generateNestedClasses(fieldGroup);

            String content = generator.getGeneratedContent("Data");
            assertNotNull(content);
            assertTrue(content.contains("public String getValue()"));
            assertTrue(content.contains("return this.value;"));
            assertTrue(content.contains("public void setValue(String value)"));
            assertTrue(content.contains("this.value = value;"));
        }

        @Test
        @DisplayName("Generates Builder class when Lombok disabled")
        void generatesBuilderWithoutLombok() {
            FieldNode objectField = FieldNode.builder()
                    .originalName("DATA")
                    .camelCaseName("data")
                    .isObject(true)
                    .children(Arrays.asList(
                            FieldNode.builder()
                                    .originalName("VALUE")
                                    .camelCaseName("value")
                                    .dataType("String")
                                    .build()
                    ))
                    .build();

            FieldGroup fieldGroup = new FieldGroup();
            fieldGroup.addField(objectField);

            generator.generateNestedClasses(fieldGroup);

            String content = generator.getGeneratedContent("Data");
            assertNotNull(content);
            assertTrue(content.contains("public static class Builder"));
            assertTrue(content.contains("public Builder value(String value)"));
            assertTrue(content.contains("public Data build()"));
            assertTrue(content.contains("public static Builder builder()"));
        }

        @Test
        @DisplayName("Generates no-arg constructor when Lombok disabled")
        void generatesNoArgConstructor() {
            FieldNode objectField = FieldNode.builder()
                    .originalName("DATA")
                    .camelCaseName("data")
                    .isObject(true)
                    .children(Arrays.asList(
                            FieldNode.builder()
                                    .originalName("VALUE")
                                    .camelCaseName("value")
                                    .dataType("String")
                                    .build()
                    ))
                    .build();

            FieldGroup fieldGroup = new FieldGroup();
            fieldGroup.addField(objectField);

            generator.generateNestedClasses(fieldGroup);

            String content = generator.getGeneratedContent("Data");
            assertNotNull(content);
            assertTrue(content.contains("public Data() {"));
        }
    }

    @Nested
    @DisplayName("Field Order Preservation Tests")
    class FieldOrderPreservationTests {

        @Test
        @DisplayName("Field order matches input order")
        void fieldOrderMatchesInput() {
            FieldNode objectField = FieldNode.builder()
                    .originalName("DATA")
                    .camelCaseName("data")
                    .isObject(true)
                    .children(Arrays.asList(
                            FieldNode.builder()
                                    .originalName("FIRST")
                                    .camelCaseName("first")
                                    .dataType("String")
                                    .build(),
                            FieldNode.builder()
                                    .originalName("SECOND")
                                    .camelCaseName("second")
                                    .dataType("String")
                                    .build(),
                            FieldNode.builder()
                                    .originalName("THIRD")
                                    .camelCaseName("third")
                                    .dataType("String")
                                    .build()
                    ))
                    .build();

            FieldGroup fieldGroup = new FieldGroup();
            fieldGroup.addField(objectField);

            generator.generateNestedClasses(fieldGroup);

            String content = generator.getGeneratedContent("Data");
            assertNotNull(content);

            int firstPos = content.indexOf("private String first;");
            int secondPos = content.indexOf("private String second;");
            int thirdPos = content.indexOf("private String third;");

            assertTrue(firstPos < secondPos, "first should come before second");
            assertTrue(secondPos < thirdPos, "second should come before third");
        }
    }

    @Nested
    @DisplayName("Package Declaration Tests")
    class PackageDeclarationTests {

        @Test
        @DisplayName("Package declaration matches config")
        void packageDeclarationMatchesConfig() {
            FieldNode objectField = FieldNode.builder()
                    .originalName("DATA")
                    .camelCaseName("data")
                    .isObject(true)
                    .children(Arrays.asList(
                            FieldNode.builder()
                                    .originalName("VALUE")
                                    .camelCaseName("value")
                                    .dataType("String")
                                    .build()
                    ))
                    .build();

            FieldGroup fieldGroup = new FieldGroup();
            fieldGroup.addField(objectField);

            generator.generateNestedClasses(fieldGroup);

            String content = generator.getGeneratedContent("Data");
            assertNotNull(content);
            assertTrue(content.startsWith("package com.rtm.test.model;"));
        }
    }

    @Nested
    @DisplayName("Import Statement Tests")
    class ImportStatementTests {

        @Test
        @DisplayName("Imports are sorted alphabetically")
        void importsAreSorted() {
            JavaConfig javaConfig = new JavaConfig();
            javaConfig.setPackageName("com.rtm.test.model");
            javaConfig.setUseLombok(true);
            config.setJava(javaConfig);
            generator = new NestedClassGenerator(config);

            FieldNode objectField = FieldNode.builder()
                    .originalName("DATA")
                    .camelCaseName("data")
                    .isObject(true)
                    .children(Arrays.asList(
                            FieldNode.builder()
                                    .originalName("AMOUNT")
                                    .camelCaseName("amount")
                                    .dataType("Amount")
                                    .build(),
                            FieldNode.builder()
                                    .originalName("ITEMS")
                                    .camelCaseName("items")
                                    .isArray(true)
                                    .className("Item")
                                    .build()
                    ))
                    .build();

            FieldGroup fieldGroup = new FieldGroup();
            fieldGroup.addField(objectField);

            generator.generateNestedClasses(fieldGroup);

            String content = generator.getGeneratedContent("Data");
            assertNotNull(content);

            int bigDecimalPos = content.indexOf("import java.math.BigDecimal;");
            int arrayListPos = content.indexOf("import java.util.ArrayList;");
            int listPos = content.indexOf("import java.util.List;");
            int lombokAllArgsPos = content.indexOf("import lombok.AllArgsConstructor;");

            assertTrue(bigDecimalPos < arrayListPos, "BigDecimal import should come before ArrayList");
            assertTrue(arrayListPos < listPos, "ArrayList import should come before List");
            assertTrue(listPos < lombokAllArgsPos, "java.util imports should come before lombok imports");
        }

        @Test
        @DisplayName("No duplicate imports")
        void noDuplicateImports() {
            FieldNode objectField = FieldNode.builder()
                    .originalName("DATA")
                    .camelCaseName("data")
                    .isObject(true)
                    .children(Arrays.asList(
                            FieldNode.builder()
                                    .originalName("AMOUNT1")
                                    .camelCaseName("amount1")
                                    .dataType("Amount")
                                    .build(),
                            FieldNode.builder()
                                    .originalName("AMOUNT2")
                                    .camelCaseName("amount2")
                                    .dataType("Currency")
                                    .build()
                    ))
                    .build();

            FieldGroup fieldGroup = new FieldGroup();
            fieldGroup.addField(objectField);

            generator.generateNestedClasses(fieldGroup);

            String content = generator.getGeneratedContent("Data");
            assertNotNull(content);

            // Count occurrences of BigDecimal import
            int count = 0;
            int index = 0;
            while ((index = content.indexOf("import java.math.BigDecimal;", index)) != -1) {
                count++;
                index++;
            }
            assertEquals(1, count, "BigDecimal import should appear exactly once");
        }
    }

    @Nested
    @DisplayName("Array Field Default Initialization Tests")
    class ArrayFieldInitializationTests {

        @Test
        @DisplayName("Array fields are initialized to empty ArrayList")
        void arrayFieldsInitializedToEmptyArrayList() {
            FieldNode objectField = FieldNode.builder()
                    .originalName("DATA")
                    .camelCaseName("data")
                    .isObject(true)
                    .children(Arrays.asList(
                            FieldNode.builder()
                                    .originalName("ITEMS")
                                    .camelCaseName("items")
                                    .isArray(true)
                                    .className("Item")
                                    .build()
                    ))
                    .build();

            FieldGroup fieldGroup = new FieldGroup();
            fieldGroup.addField(objectField);

            generator.generateNestedClasses(fieldGroup);

            String content = generator.getGeneratedContent("Data");
            assertNotNull(content);
            assertTrue(content.contains("private List<Item> items = new ArrayList<>();"));
        }
    }

    @Nested
    @DisplayName("Empty Structure Handling Tests")
    class EmptyStructureHandlingTests {

        @Test
        @DisplayName("Empty FieldGroup returns empty list")
        void emptyFieldGroupReturnsEmptyList() {
            FieldGroup fieldGroup = new FieldGroup();

            List<String> classNames = generator.generateNestedClasses(fieldGroup);

            assertTrue(classNames.isEmpty());
        }

        @Test
        @DisplayName("Null FieldGroup returns empty list")
        void nullFieldGroupReturnsEmptyList() {
            List<String> classNames = generator.generateNestedClasses(null);

            assertTrue(classNames.isEmpty());
        }

        @Test
        @DisplayName("Array with only transitory children is not generated")
        void arrayWithOnlyTransitoryChildrenNotGenerated() {
            FieldNode arrayField = FieldNode.builder()
                    .originalName("ITEMS")
                    .camelCaseName("items")
                    .isArray(true)
                    .children(Arrays.asList(
                            FieldNode.builder()
                                    .originalName("groupId")
                                    .camelCaseName("groupId")
                                    .isTransitory(true)
                                    .build()
                    ))
                    .build();

            FieldGroup fieldGroup = new FieldGroup();
            fieldGroup.addField(arrayField);

            List<String> classNames = generator.generateNestedClasses(fieldGroup);

            assertTrue(classNames.isEmpty());
        }
    }

    @Nested
    @DisplayName("File Output Tests")
    class FileOutputTests {

        @TempDir
        Path tempDir;

        @Test
        @DisplayName("Writes Java file to correct path")
        void writesJavaFileToCorrectPath() throws IOException {
            FieldNode objectField = FieldNode.builder()
                    .originalName("DATA")
                    .camelCaseName("data")
                    .isObject(true)
                    .children(Arrays.asList(
                            FieldNode.builder()
                                    .originalName("VALUE")
                                    .camelCaseName("value")
                                    .dataType("String")
                                    .build()
                    ))
                    .build();

            FieldGroup fieldGroup = new FieldGroup();
            fieldGroup.addField(objectField);

            generator.generateNestedClasses(fieldGroup, tempDir);

            Path expectedPath = tempDir.resolve("java/com/rtm/test/model/Data.java");
            assertTrue(Files.exists(expectedPath), "Java file should exist at expected path");

            String content = Files.readString(expectedPath);
            assertTrue(content.contains("public class Data"));
        }

        @Test
        @DisplayName("File is written with UTF-8 encoding")
        void fileIsWrittenWithUtf8Encoding() throws IOException {
            FieldNode objectField = FieldNode.builder()
                    .originalName("DATA")
                    .camelCaseName("data")
                    .isObject(true)
                    .children(Arrays.asList(
                            FieldNode.builder()
                                    .originalName("VALUE")
                                    .camelCaseName("value")
                                    .dataType("String")
                                    .build()
                    ))
                    .build();

            FieldGroup fieldGroup = new FieldGroup();
            fieldGroup.addField(objectField);

            generator.generateNestedClasses(fieldGroup, tempDir);

            Path expectedPath = tempDir.resolve("java/com/rtm/test/model/Data.java");
            byte[] bytes = Files.readAllBytes(expectedPath);
            String content = new String(bytes, java.nio.charset.StandardCharsets.UTF_8);
            assertTrue(content.contains("public class Data"));
        }
    }

    @Nested
    @DisplayName("Class Comment Tests")
    class ClassCommentTests {

        @Test
        @DisplayName("Array element class has correct description comment")
        void arrayElementClassHasCorrectComment() {
            FieldNode arrayField = FieldNode.builder()
                    .originalName("CBA_CARD_ARR")
                    .camelCaseName("cbaCardArr")
                    .isArray(true)
                    .children(Arrays.asList(
                            FieldNode.builder()
                                    .originalName("VALUE")
                                    .camelCaseName("value")
                                    .dataType("String")
                                    .build()
                    ))
                    .build();

            FieldGroup fieldGroup = new FieldGroup();
            fieldGroup.addField(arrayField);

            generator.generateNestedClasses(fieldGroup);

            String content = generator.getGeneratedContent("CbaCardArray");
            assertNotNull(content);
            assertTrue(content.contains("Array element class for CBA_CARD_ARR"));
        }

        @Test
        @DisplayName("Object class has correct description comment")
        void objectClassHasCorrectComment() {
            FieldNode objectField = FieldNode.builder()
                    .originalName("CREATE_APP")
                    .camelCaseName("createApp")
                    .isObject(true)
                    .children(Arrays.asList(
                            FieldNode.builder()
                                    .originalName("VALUE")
                                    .camelCaseName("value")
                                    .dataType("String")
                                    .build()
                    ))
                    .build();

            FieldGroup fieldGroup = new FieldGroup();
            fieldGroup.addField(objectField);

            generator.generateNestedClasses(fieldGroup);

            String content = generator.getGeneratedContent("CreateApp");
            assertNotNull(content);
            assertTrue(content.contains("Nested object class for CREATE_APP"));
        }

        @Test
        @DisplayName("Class has @generated marker")
        void classHasGeneratedMarker() {
            FieldNode objectField = FieldNode.builder()
                    .originalName("DATA")
                    .camelCaseName("data")
                    .isObject(true)
                    .children(Arrays.asList(
                            FieldNode.builder()
                                    .originalName("VALUE")
                                    .camelCaseName("value")
                                    .dataType("String")
                                    .build()
                    ))
                    .build();

            FieldGroup fieldGroup = new FieldGroup();
            fieldGroup.addField(objectField);

            generator.generateNestedClasses(fieldGroup);

            String content = generator.getGeneratedContent("Data");
            assertNotNull(content);
            assertTrue(content.contains("@generated by MQ Tool"));
        }
    }

    @Nested
    @DisplayName("Field Comment Tests")
    class FieldCommentTests {

        @Test
        @DisplayName("Field has original name comment when different from camelCase")
        void fieldHasOriginalNameComment() {
            FieldNode objectField = FieldNode.builder()
                    .originalName("DATA")
                    .camelCaseName("data")
                    .isObject(true)
                    .children(Arrays.asList(
                            FieldNode.builder()
                                    .originalName("CARD_NO")
                                    .camelCaseName("cardNo")
                                    .dataType("String")
                                    .length(16)
                                    .build()
                    ))
                    .build();

            FieldGroup fieldGroup = new FieldGroup();
            fieldGroup.addField(objectField);

            generator.generateNestedClasses(fieldGroup);

            String content = generator.getGeneratedContent("Data");
            assertNotNull(content);
            assertTrue(content.contains("CARD_NO (length: 16)"));
        }
    }

    @Nested
    @DisplayName("Clear and Reuse Tests")
    class ClearAndReuseTests {

        @Test
        @DisplayName("Clear resets internal state")
        void clearResetsInternalState() {
            FieldNode objectField = FieldNode.builder()
                    .originalName("DATA")
                    .camelCaseName("data")
                    .isObject(true)
                    .children(Arrays.asList(
                            FieldNode.builder()
                                    .originalName("VALUE")
                                    .camelCaseName("value")
                                    .dataType("String")
                                    .build()
                    ))
                    .build();

            FieldGroup fieldGroup = new FieldGroup();
            fieldGroup.addField(objectField);

            generator.generateNestedClasses(fieldGroup);
            assertEquals(1, generator.getAllGeneratedClassNames().size());

            generator.clear();
            assertTrue(generator.getAllGeneratedClassNames().isEmpty());
            assertNull(generator.getGeneratedContent("Data"));
        }

        @Test
        @DisplayName("Generator can be reused after clear")
        void generatorCanBeReusedAfterClear() {
            FieldNode objectField1 = FieldNode.builder()
                    .originalName("DATA1")
                    .camelCaseName("data1")
                    .isObject(true)
                    .children(Arrays.asList(
                            FieldNode.builder()
                                    .originalName("VALUE")
                                    .camelCaseName("value")
                                    .dataType("String")
                                    .build()
                    ))
                    .build();

            FieldGroup fieldGroup1 = new FieldGroup();
            fieldGroup1.addField(objectField1);

            generator.generateNestedClasses(fieldGroup1);
            generator.clear();

            FieldNode objectField2 = FieldNode.builder()
                    .originalName("DATA2")
                    .camelCaseName("data2")
                    .isObject(true)
                    .children(Arrays.asList(
                            FieldNode.builder()
                                    .originalName("VALUE")
                                    .camelCaseName("value")
                                    .dataType("String")
                                    .build()
                    ))
                    .build();

            FieldGroup fieldGroup2 = new FieldGroup();
            fieldGroup2.addField(objectField2);

            List<String> classNames = generator.generateNestedClasses(fieldGroup2);

            assertEquals(1, classNames.size());
            assertEquals("Data2", classNames.get(0));
            assertNotNull(generator.getGeneratedContent("Data2"));
            assertNull(generator.getGeneratedContent("Data1"));
        }
    }
}
