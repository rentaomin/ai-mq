package com.rtm.mq.tool.generator.java;

import com.rtm.mq.tool.config.Config;
import com.rtm.mq.tool.config.JavaConfig;
import com.rtm.mq.tool.config.OutputConfig;
import com.rtm.mq.tool.exception.GenerationException;
import com.rtm.mq.tool.model.FieldGroup;
import com.rtm.mq.tool.model.FieldNode;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;

import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Unit tests for EnumHelperGenerator.
 *
 * <p>Tests cover:</p>
 * <ul>
 *   <li>Enum class generation from field constraints</li>
 *   <li>Enum value naming rules (pure digits, letters, mixed)</li>
 *   <li>fromCode and isValid method generation</li>
 *   <li>Duplicate enum detection and deduplication</li>
 *   <li>Nested field traversal</li>
 *   <li>Error handling for invalid constraints</li>
 * </ul>
 */
class EnumHelperGeneratorTest {

    private Config config;
    private EnumHelperGenerator generator;

    @TempDir
    Path tempDir;

    @BeforeEach
    void setUp() {
        config = new Config();
        config.setDefaults();

        OutputConfig outputConfig = new OutputConfig();
        outputConfig.setRootDir(tempDir.toString());
        config.setOutput(outputConfig);

        JavaConfig javaConfig = new JavaConfig();
        javaConfig.setPackageName("com.rtm.test.model");
        config.setJava(javaConfig);

        generator = new EnumHelperGenerator(config);
    }

    @Nested
    @DisplayName("Enum Class Generation Tests")
    class EnumClassGenerationTests {

        @Test
        @DisplayName("Generates enum class for field with enumConstraint")
        void generatesEnumClassForField() throws GenerationException {
            FieldNode field = FieldNode.builder()
                    .originalName("CARD_TYPE")
                    .camelCaseName("cardType")
                    .enumConstraint("01|02|03")
                    .build();

            FieldGroup group = new FieldGroup();
            group.addField(field);

            List<String> generatedNames = generator.generateEnumClasses(group);

            assertEquals(1, generatedNames.size());
            assertEquals("CardType", generatedNames.get(0));

            String content = generator.getGeneratedContent("CardType");
            assertNotNull(content);
            assertTrue(content.contains("public enum CardType"));
            assertTrue(content.contains("package com.rtm.test.model;"));
        }

        @Test
        @DisplayName("Generated enum contains @generated tag")
        void generatedEnumContainsGeneratedTag() throws GenerationException {
            FieldNode field = FieldNode.builder()
                    .originalName("STATUS")
                    .camelCaseName("status")
                    .enumConstraint("A|B")
                    .build();

            FieldGroup group = new FieldGroup();
            group.addField(field);

            generator.generateEnumClasses(group);

            String content = generator.getGeneratedContent("Status");
            assertTrue(content.contains("@generated by MQ Tool"));
        }

        @Test
        @DisplayName("Empty FieldGroup returns empty list")
        void emptyFieldGroupReturnsEmptyList() throws GenerationException {
            FieldGroup group = new FieldGroup();

            List<String> generatedNames = generator.generateEnumClasses(group);

            assertTrue(generatedNames.isEmpty());
        }

        @Test
        @DisplayName("Null FieldGroup returns empty list")
        void nullFieldGroupReturnsEmptyList() throws GenerationException {
            List<String> generatedNames = generator.generateEnumClasses(null);

            assertTrue(generatedNames.isEmpty());
        }
    }

    @Nested
    @DisplayName("Enum Value Naming Tests")
    class EnumValueNamingTests {

        @Test
        @DisplayName("Pure digit codes get VALUE_ prefix")
        void pureDigitCodesGetValuePrefix() throws GenerationException {
            FieldNode field = FieldNode.builder()
                    .originalName("CODE_TYPE")
                    .camelCaseName("codeType")
                    .enumConstraint("01|02|99")
                    .build();

            FieldGroup group = new FieldGroup();
            group.addField(field);

            generator.generateEnumClasses(group);

            String content = generator.getGeneratedContent("CodeType");
            assertTrue(content.contains("VALUE_01"));
            assertTrue(content.contains("VALUE_02"));
            assertTrue(content.contains("VALUE_99"));
        }

        @Test
        @DisplayName("Pure uppercase letters are used directly")
        void pureUppercaseLettersUsedDirectly() throws GenerationException {
            FieldNode field = FieldNode.builder()
                    .originalName("YES_NO_FLAG")
                    .camelCaseName("yesNoFlag")
                    .enumConstraint("Y|N")
                    .build();

            FieldGroup group = new FieldGroup();
            group.addField(field);

            generator.generateEnumClasses(group);

            String content = generator.getGeneratedContent("YesNoFlag");
            assertTrue(content.contains("Y(\"Y\""));
            assertTrue(content.contains("N(\"N\""));
        }

        @Test
        @DisplayName("Mixed case codes are converted to uppercase")
        void mixedCaseCodesConvertedToUppercase() throws GenerationException {
            FieldNode field = FieldNode.builder()
                    .originalName("MixedType")
                    .camelCaseName("mixedType")
                    .enumConstraint("Ab|Cd")
                    .build();

            FieldGroup group = new FieldGroup();
            group.addField(field);

            generator.generateEnumClasses(group);

            String content = generator.getGeneratedContent("MixedType");
            assertTrue(content.contains("AB(\"Ab\""));
            assertTrue(content.contains("CD(\"Cd\""));
        }
    }

    @Nested
    @DisplayName("Helper Method Generation Tests")
    class HelperMethodGenerationTests {

        @Test
        @DisplayName("Generates fromCode static method")
        void generatesFromCodeMethod() throws GenerationException {
            FieldNode field = FieldNode.builder()
                    .originalName("TYPE")
                    .camelCaseName("type")
                    .enumConstraint("A|B")
                    .build();

            FieldGroup group = new FieldGroup();
            group.addField(field);

            generator.generateEnumClasses(group);

            String content = generator.getGeneratedContent("Type");
            assertTrue(content.contains("public static Type fromCode(String code)"));
            assertTrue(content.contains("if (code == null)"));
            assertTrue(content.contains("return null;"));
            assertTrue(content.contains("if (value.code.equals(code))"));
        }

        @Test
        @DisplayName("Generates isValid static method")
        void generatesIsValidMethod() throws GenerationException {
            FieldNode field = FieldNode.builder()
                    .originalName("TYPE")
                    .camelCaseName("type")
                    .enumConstraint("A|B")
                    .build();

            FieldGroup group = new FieldGroup();
            group.addField(field);

            generator.generateEnumClasses(group);

            String content = generator.getGeneratedContent("Type");
            assertTrue(content.contains("public static boolean isValid(String code)"));
            assertTrue(content.contains("return fromCode(code) != null;"));
        }

        @Test
        @DisplayName("Generates getCode instance method")
        void generatesGetCodeMethod() throws GenerationException {
            FieldNode field = FieldNode.builder()
                    .originalName("TYPE")
                    .camelCaseName("type")
                    .enumConstraint("A|B")
                    .build();

            FieldGroup group = new FieldGroup();
            group.addField(field);

            generator.generateEnumClasses(group);

            String content = generator.getGeneratedContent("Type");
            assertTrue(content.contains("public String getCode()"));
            assertTrue(content.contains("return code;"));
        }

        @Test
        @DisplayName("Generates getDescription instance method")
        void generatesGetDescriptionMethod() throws GenerationException {
            FieldNode field = FieldNode.builder()
                    .originalName("TYPE")
                    .camelCaseName("type")
                    .enumConstraint("A|B")
                    .build();

            FieldGroup group = new FieldGroup();
            group.addField(field);

            generator.generateEnumClasses(group);

            String content = generator.getGeneratedContent("Type");
            assertTrue(content.contains("public String getDescription()"));
            assertTrue(content.contains("return description;"));
        }
    }

    @Nested
    @DisplayName("Constructor Generation Tests")
    class ConstructorGenerationTests {

        @Test
        @DisplayName("Generates enum constructor with code and description")
        void generatesConstructorWithCodeAndDescription() throws GenerationException {
            FieldNode field = FieldNode.builder()
                    .originalName("TYPE")
                    .camelCaseName("type")
                    .enumConstraint("A|B")
                    .build();

            FieldGroup group = new FieldGroup();
            group.addField(field);

            generator.generateEnumClasses(group);

            String content = generator.getGeneratedContent("Type");
            assertTrue(content.contains("Type(String code, String description)"));
            assertTrue(content.contains("this.code = code;"));
            assertTrue(content.contains("this.description = description;"));
        }

        @Test
        @DisplayName("Generates private final fields for code and description")
        void generatesPrivateFinalFields() throws GenerationException {
            FieldNode field = FieldNode.builder()
                    .originalName("TYPE")
                    .camelCaseName("type")
                    .enumConstraint("A|B")
                    .build();

            FieldGroup group = new FieldGroup();
            group.addField(field);

            generator.generateEnumClasses(group);

            String content = generator.getGeneratedContent("Type");
            assertTrue(content.contains("private final String code;"));
            assertTrue(content.contains("private final String description;"));
        }
    }

    @Nested
    @DisplayName("Deduplication Tests")
    class DeduplicationTests {

        @Test
        @DisplayName("Same enum class name is generated only once")
        void sameEnumClassGeneratedOnce() throws GenerationException {
            FieldNode field1 = FieldNode.builder()
                    .originalName("STATUS")
                    .camelCaseName("status")
                    .enumConstraint("A|B")
                    .build();

            FieldNode field2 = FieldNode.builder()
                    .originalName("STATUS_2")
                    .camelCaseName("status")
                    .enumConstraint("C|D")
                    .build();

            FieldGroup group = new FieldGroup();
            group.addField(field1);
            group.addField(field2);

            List<String> generatedNames = generator.generateEnumClasses(group);

            assertEquals(1, generatedNames.size());
            assertEquals(1, generator.getAllGeneratedEnumNames().size());
        }
    }

    @Nested
    @DisplayName("Nested Field Traversal Tests")
    class NestedFieldTraversalTests {

        @Test
        @DisplayName("Processes enum fields in nested structures")
        void processesEnumFieldsInNestedStructures() throws GenerationException {
            FieldNode nestedEnumField = FieldNode.builder()
                    .originalName("NESTED_STATUS")
                    .camelCaseName("nestedStatus")
                    .enumConstraint("X|Y|Z")
                    .build();

            FieldNode parentField = FieldNode.builder()
                    .originalName("PARENT")
                    .camelCaseName("parent")
                    .isObject(true)
                    .children(List.of(nestedEnumField))
                    .build();

            FieldGroup group = new FieldGroup();
            group.addField(parentField);

            List<String> generatedNames = generator.generateEnumClasses(group);

            assertEquals(1, generatedNames.size());
            assertEquals("NestedStatus", generatedNames.get(0));
        }

        @Test
        @DisplayName("Skips transitory fields")
        void skipsTransitoryFields() throws GenerationException {
            FieldNode transitoryField = FieldNode.builder()
                    .originalName("SKIP_THIS")
                    .camelCaseName("skipThis")
                    .enumConstraint("A|B")
                    .isTransitory(true)
                    .build();

            FieldGroup group = new FieldGroup();
            group.addField(transitoryField);

            List<String> generatedNames = generator.generateEnumClasses(group);

            assertTrue(generatedNames.isEmpty());
        }
    }

    @Nested
    @DisplayName("Error Handling Tests")
    class ErrorHandlingTests {

        @Test
        @DisplayName("Throws exception for empty enumConstraint on detected enum field")
        void throwsExceptionForEmptyEnumConstraint() {
            // Create a field that has a constraint with only pipe but no values
            FieldNode field = FieldNode.builder()
                    .originalName("BAD_ENUM")
                    .camelCaseName("badEnum")
                    .enumConstraint("|")
                    .build();

            FieldGroup group = new FieldGroup();
            group.addField(field);

            assertThrows(GenerationException.class, () -> generator.generateEnumClasses(group));
        }

        @Test
        @DisplayName("Throws exception when all enum values are empty after parsing")
        void throwsExceptionWhenAllValuesEmpty() {
            FieldNode field = FieldNode.builder()
                    .originalName("BAD_ENUM")
                    .camelCaseName("badEnum")
                    .enumConstraint("| | |")
                    .build();

            FieldGroup group = new FieldGroup();
            group.addField(field);

            assertThrows(GenerationException.class, () -> generator.generateEnumClasses(group));
        }
    }

    @Nested
    @DisplayName("File Output Tests")
    class FileOutputTests {

        @Test
        @DisplayName("Writes enum class to correct file path")
        void writesEnumClassToCorrectPath() throws Exception {
            FieldNode field = FieldNode.builder()
                    .originalName("FILE_TYPE")
                    .camelCaseName("fileType")
                    .enumConstraint("PDF|DOC")
                    .build();

            FieldGroup group = new FieldGroup();
            group.addField(field);

            generator.generateEnumClasses(group);

            Path expectedFile = tempDir.resolve("java/com/rtm/test/model/FileType.java");
            assertTrue(Files.exists(expectedFile), "Expected file: " + expectedFile);

            String fileContent = Files.readString(expectedFile);
            assertTrue(fileContent.contains("public enum FileType"));
        }

        @Test
        @DisplayName("Uses UTF-8 encoding for output files")
        void usesUtf8Encoding() throws Exception {
            FieldNode field = FieldNode.builder()
                    .originalName("UTF_TYPE")
                    .camelCaseName("utfType")
                    .enumConstraint("A|B")
                    .build();

            FieldGroup group = new FieldGroup();
            group.addField(field);

            generator.generateEnumClasses(group);

            Path expectedFile = tempDir.resolve("java/com/rtm/test/model/UtfType.java");
            byte[] bytes = Files.readAllBytes(expectedFile);
            String content = new String(bytes, java.nio.charset.StandardCharsets.UTF_8);

            assertTrue(content.contains("public enum UtfType"));
        }
    }

    @Nested
    @DisplayName("Package Declaration Tests")
    class PackageDeclarationTests {

        @Test
        @DisplayName("Package declaration matches config")
        void packageDeclarationMatchesConfig() throws GenerationException {
            FieldNode field = FieldNode.builder()
                    .originalName("PKG_TYPE")
                    .camelCaseName("pkgType")
                    .enumConstraint("A|B")
                    .build();

            FieldGroup group = new FieldGroup();
            group.addField(field);

            generator.generateEnumClasses(group);

            String content = generator.getGeneratedContent("PkgType");
            assertTrue(content.startsWith("package com.rtm.test.model;\n"));
        }
    }

    @Nested
    @DisplayName("Enum Class Name Derivation Tests")
    class EnumClassNameDerivationTests {

        @Test
        @DisplayName("Derives PascalCase class name from camelCase field name")
        void derivesPascalCaseFromCamelCase() throws GenerationException {
            FieldNode field = FieldNode.builder()
                    .originalName("SOME_STATUS")
                    .camelCaseName("someStatus")
                    .enumConstraint("A|B")
                    .build();

            FieldGroup group = new FieldGroup();
            group.addField(field);

            List<String> generatedNames = generator.generateEnumClasses(group);

            assertEquals("SomeStatus", generatedNames.get(0));
        }

        @Test
        @DisplayName("Class name ending with Type is preserved")
        void classNameEndingWithTypePreserved() throws GenerationException {
            FieldNode field = FieldNode.builder()
                    .originalName("CARD_TYPE")
                    .camelCaseName("cardType")
                    .enumConstraint("01|02")
                    .build();

            FieldGroup group = new FieldGroup();
            group.addField(field);

            List<String> generatedNames = generator.generateEnumClasses(group);

            assertEquals("CardType", generatedNames.get(0));
        }

        @Test
        @DisplayName("Class name ending with Status is preserved")
        void classNameEndingWithStatusPreserved() throws GenerationException {
            FieldNode field = FieldNode.builder()
                    .originalName("APP_STATUS")
                    .camelCaseName("appStatus")
                    .enumConstraint("PENDING|APPROVED")
                    .build();

            FieldGroup group = new FieldGroup();
            group.addField(field);

            List<String> generatedNames = generator.generateEnumClasses(group);

            assertEquals("AppStatus", generatedNames.get(0));
        }

        @Test
        @DisplayName("Class name ending with Flag is preserved")
        void classNameEndingWithFlagPreserved() throws GenerationException {
            FieldNode field = FieldNode.builder()
                    .originalName("YES_NO_FLAG")
                    .camelCaseName("yesNoFlag")
                    .enumConstraint("Y|N")
                    .build();

            FieldGroup group = new FieldGroup();
            group.addField(field);

            List<String> generatedNames = generator.generateEnumClasses(group);

            assertEquals("YesNoFlag", generatedNames.get(0));
        }
    }

    @Nested
    @DisplayName("getAllGeneratedEnumNames Tests")
    class GetAllGeneratedEnumNamesTests {

        @Test
        @DisplayName("Returns all generated enum names in order")
        void returnsAllGeneratedEnumNamesInOrder() throws GenerationException {
            FieldNode field1 = FieldNode.builder()
                    .originalName("FIRST")
                    .camelCaseName("first")
                    .enumConstraint("A|B")
                    .build();

            FieldNode field2 = FieldNode.builder()
                    .originalName("SECOND")
                    .camelCaseName("second")
                    .enumConstraint("X|Y")
                    .build();

            FieldGroup group = new FieldGroup();
            group.addField(field1);
            group.addField(field2);

            generator.generateEnumClasses(group);

            List<String> allNames = generator.getAllGeneratedEnumNames();
            assertEquals(2, allNames.size());
            assertEquals("First", allNames.get(0));
            assertEquals("Second", allNames.get(1));
        }

        @Test
        @DisplayName("Returns empty list when no enums generated")
        void returnsEmptyListWhenNoEnumsGenerated() throws GenerationException {
            FieldGroup group = new FieldGroup();
            generator.generateEnumClasses(group);

            List<String> allNames = generator.getAllGeneratedEnumNames();
            assertTrue(allNames.isEmpty());
        }
    }

    @Nested
    @DisplayName("Enum Constraint Parsing Tests")
    class EnumConstraintParsingTests {

        @Test
        @DisplayName("Handles whitespace around enum values")
        void handlesWhitespaceAroundEnumValues() throws GenerationException {
            FieldNode field = FieldNode.builder()
                    .originalName("SPACED")
                    .camelCaseName("spaced")
                    .enumConstraint(" A | B | C ")
                    .build();

            FieldGroup group = new FieldGroup();
            group.addField(field);

            generator.generateEnumClasses(group);

            String content = generator.getGeneratedContent("Spaced");
            assertTrue(content.contains("A(\"A\""));
            assertTrue(content.contains("B(\"B\""));
            assertTrue(content.contains("C(\"C\""));
        }

        @Test
        @DisplayName("Ignores empty values between pipes")
        void ignoresEmptyValuesBetweenPipes() throws GenerationException {
            FieldNode field = FieldNode.builder()
                    .originalName("GAPS")
                    .camelCaseName("gaps")
                    .enumConstraint("A||B")
                    .build();

            FieldGroup group = new FieldGroup();
            group.addField(field);

            generator.generateEnumClasses(group);

            String content = generator.getGeneratedContent("Gaps");
            assertTrue(content.contains("A(\"A\""));
            assertTrue(content.contains("B(\"B\""));
            // Should not have an empty value
            assertFalse(content.contains("(\"\", \"\")"));
        }
    }
}
