### Claude code 使用遵循原则

- 1、在需求分析，架构设计，任务拆分时，禁止生成不必要的代码实现示例，仅在实现任务时生成具体代码
- 2、在生成代码时，禁止添加不必要的模板注释，仅在复杂关键逻辑上增加必要注释
- 3、生成代码时，禁止生成过多的测试用例，仅生成最小化测试用例，不超过3条。
- 4、禁止在实现任务时，执行 maven 编译，npm install 等测试命令，通过hook+script执行
- 5、禁止在执行任务后，输出超过100字符的总结内容
- 6、生成的文档文件使用英文输出，确保语言精简，避免冗余
- 7、生成的文档文件如果存在过多示例片段，则通过拆分引用文件进行引用说明，明确必须引用或可选引用
- 8、架构设计中，对于后续产生的内容输出路径，应统一明确
- 9、在输出内容前进行思考，仅输出必要内容，减少冗余内容
- 10、用多文件替代常文件，但保持结构稳定


# Claude Code 复杂工程低 Token 实战经验

本文总结 Claude Code 在“需求分析 → 架构设计 → 任务拆分 → 任务实现 → 验证收尾”的全流程使用原则，核心目标：
- 避免无关上下文与无效输出导致的 token 浪费
- 保持产出高质量、可落地、可复现
- 降低返工概率（返工是 token 消耗最大来源）

---

## 0. 总体原则（全阶段通用）

### 0.1 单次调用的“输入预算”与“输出预算”
- 输入必须最小化：一次只解决一个明确目标，禁止携带无关文档。
- 输出必须可控：默认输出“结论 + 变更清单 + 验收勾选”，禁止长篇解释与大段代码贴出（除非明确要求审查）。

**建议硬规则：**
- 单次任务输入：只允许 `1 个 task 文件 + ≤3 个依赖契约文件`
- 单次输出：默认 ≤ 200~400 行（实现阶段更低）

### 0.2 冻结“契约层”，减少反复对齐
复杂工程 token 大头往往来自“接口/模型/配置反复修改导致全链路重读与重写”。

**冻结点建议：**
- Gate0 完成后冻结：核心接口（Generator/Validator/Audit/OutputManager）、数据模型（Intermediate Tree）、退出码与错误模型、配置 schema
- 若必须改契约：走 ADR（Decision Log）并写明影响面

### 0.3 先固化确定性（Determinism），再扩功能
任何生成器/验证器都必须遵守：
- 顺序稳定
- 输出稳定（格式与字段顺序）
- 同输入同版本 → 同输出（hash 相同）

确定性没固化之前推进功能，只会把后续调试成本指数放大。

### 0.4 “少读文件”比“少写字”更重要
Claude Code token 的主要风险来自：
- 读取大文件（architecture/dag/reference）
- repo 扫描过多文件
- 一次读多个任务文件

必须通过 command/agent 约束“读取范围”，否则靠人工自觉会失效。

---

## 1. 需求分析阶段（Requirements）

### 1.1 只写“可验收”的需求，不写实现
- 禁止代码示例、测试代码、类/方法命名实现细节（除非属于强约束接口契约）
- 输出重点：边界、非目标、验收标准、输入输出工件清单

### 1.2 用“条款化”替代长段描述
- FR/NFR/VR/AC 编号化
- 规则以表格/列表表达，避免长段自然语言导致歧义和重复解释

### 1.3 示例文件引用策略
- 不在需求文档里粘贴大段示例内容
- 用路径引用 + 说明“哪些章节/哪些关键字段约束来自示例”

---

## 2. 架构设计阶段（Architecture）

### 2.1 架构文档不做硬长度限制，改为“拆文件”
单文件硬限长会牺牲关键约束（错误处理、算法边界、可复现策略）。正确做法：
- `design/architecture.md`：只保留总览、模块边界、关键约束与数据流
- `design/modules/*.md`：各模块设计细节（parser/xml/java/oas/validators/audit/output）
- `design/data/*.md`：中间结构 schema、offset 模型、类型映射

### 2.2 所有算法必须包含“不变量（Invariant）”
算法描述必须写明：
- 输入假设
- 输出保证
- 失败条件
- 顺序/确定性保证
  否则实现阶段会反复问/反复读大文档，token 上升。

### 2.3 待确认事项（TBC/OQ）必须转 ADR/Spike
架构里出现 TBD 不要让实现阶段“凭感觉补齐”，应输出：
- Spike 任务（验证可行性）
- ADR 决策（选型与取舍）
  这能显著降低后续返工与上下文反复加载。

---

## 3. 任务拆分阶段（Task Pack / WBS）

### 3.1 任务拆分产物必须“无实现内容”
任务拆分只应包含：
- Goal / Scope（in/out）
- Inputs / Outputs（路径级）
- Dependencies（Task IDs）
- Acceptance Criteria（可测）
- Tests（仅“最小测试策略”，不要测试代码）
- Risks / Edge Cases

**禁止：**
- 代码示例（哪怕是伪代码）
- 测试代码片段
- 长篇注释模板

> 任务拆分阶段包含大量代码示例/用例会直接导致：后续每次实现都重复读取这些内容，token 成本倍增。

### 3.2 拆分原则：最小化依赖、最大化并行、契约优先
- 先出契约（接口、模型、schema、配置键）
- 再并行出实现（parser vs generators vs validators）
- Gate1 必须串行（中间 JSON Tree 是单一事实源）

### 3.3 批次化生成（避免一次生成全包爆 token）
- DAG / serial / parallel 可一次生成
- tasks/ 目录可按 Gate 分批生成（每次 3~5 个 task）
- 已存在的 task 文件不重写，避免重复消耗

---

## 4. 任务实现阶段（Implementation）

### 4.1 单 task 实现铁律
每次只实现一个 `T-xxx.md`：
- 不允许一次实现多个 task
- 不允许“顺手重构”
- 不允许回读 architecture/dag（除非 task 明确要求）

### 4.2 实现 agent 的输出应极简
默认输出模板：
- Summary（≤5 行）
- Files changed/added（列表）
- AC checklist（逐条勾选）
- 如需贴代码：只贴关键片段（≤20 行/片段）

### 4.3 引用文件策略：只读 snippet，不读大 reference
将示例拆到 `reference/snippets/*.md`（每个 ≤80 行）。
实现时：
- 只有在 task 明确要求时才读 snippet
- 每次最多读 1 个 snippet
- 禁止读取大 reference 全文件（>200 行）

### 4.4 本地验证替代“让模型写长测试说明”
- 模型写最小单测即可
- 更重要的是脚本化本地验证（mvn test / openapi validate / diff check）
- 把验证交给机器执行，减少对话解释成本

---

## 5. 验证与收尾阶段（Gate3 / CI）

### 5.1 Gate3 不等于“补测试”
Gate3 的价值是门禁与可交付：
- Consistency validator（跨制品一致性）
- Offset calculator / message validator（如需求要求）
- Atomic output / rollback（防止半成品输出）
- Audit log（可追溯、可复现）
- CLI 稳定入口

测试不是越多越好，优先：
- 1 个 golden e2e（固定输入 → 固定输出 hash）
- 少量关键单测覆盖核心逻辑分支

### 5.2 报告必须机器可读
- 任何 validator 输出都应有 `.json` 报告
- `.md` 仅用于人读摘要
  机器可读能减少“让模型解释报告”的 token 消耗。

---

## 6. 典型高 Token 反模式（必须避免）

1) 实现阶段反复粘贴/引用 architecture.md、dag.md、requirements.md 全文
2) 一个命令同时生成/实现多个任务
3) 任务文件里包含大量代码示例与测试代码
4) 允许模型“自由扫描仓库”寻找上下文
5) 输出大段解释、贴完整代码、贴大量测试用例
6) 未冻结契约层导致下游反复对齐与返工

---

## 7. 可直接复用的“低 Token 强约束模板”

### 7.1 Implementation command 的强约束段落（建议写入 /impl-task）
- 仅实现一个任务文件
- 禁止读取 architecture/dag
- 如需示例仅允许读取一个 snippet（≤80 行）
- 输出必须极简（summary + file list + AC checklist）

### 7.2 Task Spec 的瘦身模板（用于清洗过长任务）
每个 T-xxx 只保留：
- Goal
- In/Out of scope
- Inputs
- Outputs
- Dependencies
- Acceptance Criteria
- Tests（最小策略）
- Risks/Edge Cases

---

## 8. 经验结论（最重要的三句话）

1) token 消耗的最大来源是“返工”和“反复读大上下文”，不是“单次输出多几段文字”。
2) 复杂工程必须靠 Gate/契约/脚本化门禁约束模型行为，靠提示词自觉会失效。
3) 最省 token 的方式是：单 task、少读文件、极简输出、确定性先行、验证交给机器。
